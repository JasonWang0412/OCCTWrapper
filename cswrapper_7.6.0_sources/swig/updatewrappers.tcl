# Created: 2006-06-22

# Copyright (c) 2006-2021 OPEN CASCADE SAS

# This file is part of commercial software by OPEN CASCADE SAS.

# This software is furnished in accordance with the terms and conditions
# of the contract and with the inclusion of this copyright notice.
# This software or any other copy thereof may not be provided or otherwise
# be made available to any third party.

# No ownership title to the software is transferred hereby.

# OPEN CASCADE SAS makes no representation or warranties with respect to the
# performance of this software, and specifically disclaims any responsibility
# for any damages, special or consequential, connected with its use.

# This TCL script modifies wrapper files generated by SWIG by putting each 
# class into namespace named like its package (C# only), and adding 
# documentation extracted from hxx file (C# and Java)
#
# In addition, for CSharp, if environment variable CSHARP2COM is defined,
# it adds special declaration before each wrapper class to have its
# methods exported to COM / OLE
#
# The script should be run with two arguments:
# - target language: "csharp" or "java"
# - path to wrappers

# check target language and define extension
set wtype [lindex $argv 0]
set wext ""
if { $wtype == {csharp} } {
    set wext cs
} elseif { $wtype == {java} } {
    set wext java
} else {
    error "Error: first argument \"$wtype\" is not supported, must be \"csharp\" or \"java\""
}

# go to wrappers directory
set wdir [lindex $argv 1]
set aWorkDirBack [pwd]
cd "$wdir"

# auxiliary: decode file name as package name, class, and extension
proc FileAsPackNameExt {file pack_ name_ ext_} {
    upvar $pack_ pack
    upvar $name_ name
    upvar $ext_ ext
    if { ! [regexp {^([A-Za-z][A-Za-z0-9]*)_([A-Za-z0-9_]+)[.]([A-Za-z0-9]+)} $file match pack name ext] } {
        if { [regexp {^([A-Za-z][A-Za-z0-9]*)[.]([A-Za-z0-9-]+)} $file match pack ext] } {
            set name ""
        } else {
            return 0
        }
    }
#    puts "$pack _ $name . $ext"
    return 1
}

# auxiliary: load Doxygen comments to class and its methods from hxx file
proc LoadDoxyComments {thePackage class comments_ theDeprecations} {
    global env
    global wtype
    upvar $comments_ comments
    upvar $theDeprecations aDeprecations

    if { [info exists env(CASROOT)] && [file exists $env(CASROOT)/src/${thePackage}/${class}.hxx] } {
        set file $env(CASROOT)/src/${thePackage}/${class}.hxx
    } elseif { [info exists env(CSF_OCCTIncludePath)] && "$::env(CSF_OCCTIncludePath)" != "" } {
        set file $env(CSF_OCCTIncludePath)/${class}.hxx
    } else {
        set file $env(CASROOT)/inc/${class}.hxx
    }
    if {! [file exists $file] } {
        puts "Warning: No header file is found for class or enum $class in $env(CASROOT)/inc"
        return 0
    }

    # currently parsed comment
    set text {}
    set in_class 0
    set fd [open $file r]
    set aDeprText {}
    while {[gets $fd line] >= 0} {
        if [regexp {^[ \t]*//[!/](.*)} $line string comment] {
            # remove end-of-line <br>s
            set comment [regsub -all {<br>} $comment ""]
            if { $wtype == {csharp} } {
                # convert all <> to xml special names
                set comment [regsub -all {<} $comment "\\\&lt;"]
                set comment [regsub -all {>} $comment "\\\&gt;"]
                set comment [regsub -all {\&} $comment "\\\&amp;"]
            } elseif { $wtype == {java} } {
                # preventing unicode errors
                set comment [regsub -all {\\u} $comment {\\\\u}]
            }
            lappend text $comment
        } elseif [regexp {Standard_DEPRECATED\s*[\(]\s*[\"](.*)[\"]\s*[)]} $line string aDeprTextVar] {
            set aDeprText "$aDeprTextVar"
        } elseif [regexp "(class|enum) $class" $line string] {
            set in_class 1
            # comment to the class
            if { [llength $text] > 0 } {
                set comments($class) $text
#                puts "Comment to class $class: \n$text"
            }
            if { [llength $aDeprText] > 0 } {
                set aDeprecations($class) $aDeprText
            }
            set text {}
            set aDeprText {}
        } elseif { $in_class && [regexp {([A-Za-z0-9_]+)[ \t]*\(} $line string method] } {
            # count overloaded methods
            if {! [info exists count($method)] } {
                set count($method) 0
                if { "$method" == "$class" && $wtype == {csharp} } {
                    # the first constructor is generated by SWIG (for wrapping C++ pointers)
                    incr count($method)
                }
            }
            incr count($method)
            # comment to the method
            if { [llength $text] >0 } {
                set comments(${class}::${method}::$count($method)) $text
            }
            if { [llength $aDeprText] > 0 } {
                set aDeprecations(${class}::${method}::$count($method)) $aDeprText
            }
            set text {}
            set aDeprText {}
        } else {
            # not a comment, clear current text
            set text {}
            set aDeprText {}
        }
    }
    close $fd
    return 1
}

# auxiliary: Search used OCCT classes in cs/java code
proc SearchUsed {wfile pack packages_} {
  upvar $packages_ packages

  # currently read file line-by-line
  set fd [open $wfile r]
  while {[gets $fd line] >= 0} {

    # skip comments
    if [regexp {^[\s]*//(.*)} $line string comment] {
      continue
    }

    # iterate by IDs found in the line
    foreach token [split $line { .,:;<>()*/+-\{\}}] {
      # avoid recognizing GC (C# garbage collector) as OCCT package GC
      if { $token == "GC" } { continue }

      # take only part of Id until the first underscore
      if { ! [regexp {([A-Za-z][A-Za-z0-9]*)} $token dummy id] } {
        continue
      }
      
      # add as used package if id is equal to one of known packages
      if { $id != $pack && [info exists packages($id)] } {
        set used($id) 1
      }
    }
  }
  close $fd

  # make sorted list
  set lused [lsort [array names used]]
  puts "Used packages: $lused"
  return $lused
}

# Main procedure
if { ! [catch "glob *.$wext" wlist] } {
  # Iterate by generated wrapper files and collect list of 
  # wrapped OCC packages (those for which dependencies are known)
  foreach wfile $wlist {
    # Skip auxiliary files generated by SWIG
    if { [regexp {^(SWIGTYPE_|OCCwrapCSharp|OCCwrapJava)} $wfile] } {
        continue
    }

    # Analyse file name
    FileAsPackNameExt $wfile pack name ext
    set packages($pack) 1
  }

  # Iterate by generated wrapper files
  foreach wfile $wlist {
  
    # Analyse file name
    FileAsPackNameExt $wfile pack name ext

    set class [regsub ".$wext" $wfile ""]
    puts "Processing file $wfile"

    set fdin  [open $wfile r]
    
    if { $wtype == {csharp} } {
        # just skip files with artifical namespaces
        set isToContinue 1
        while { $isToContinue == 1 && [gets $fdin line] >= 0 } {
            if {[regexp "namespace" $line string] != 0} {
                set isToContinue 0
            }
        }
        
        if {$isToContinue == 0} {
            close $fdin
            continue
        } else {
            seek $fdin 0
        }
    }
    
    set fdout [open $wfile.new w]

    if { $wtype == {java} } {
        # deleting automaticly generated header
        while {[gets $fdin line] >= 0 && [regexp "package" $line string] == 0 } {
            continue
        }
        puts $fdout $line
    }

    # add namespace declaration and using statements
    if { $wtype == {csharp} } {
        # put OCC namespace to avoid collisions with native namespaces and classes.
        puts $fdout "namespace OCC \{"
    }
        
    if [info exists packages($pack)] {
        if { $wtype == {csharp} } {
            # wrapped class
            puts $fdout "namespace $pack \{"
            puts $fdout "using SWIG;"
            foreach pk [SearchUsed $wfile $pack packages] { 
                puts $fdout "using $pk;"
            }
        }

        # load Doxygen comments from the header file
        LoadDoxyComments $pack $class comments aDeprecations
    } elseif { $wtype == {csharp} } {
        # not a wrapped type (SWIG mechanics)
        puts $fdout "namespace SWIG \{"
        foreach pk [array names packages] {
            puts $fdout "using $pk;"
        }
    }

    # copy original file
    set in_class 0
    if [info exists count] { unset count }
    while {[gets $fdin line] >= 0} {
        # put documentation comments
        set comment {}
        set space ""
        set attribute ""
        if [regexp "public (class|enum|final class) $class" $line string type] {
            set in_class 1
            # comment to the class
            if [info exists comments($class)] {
                set comment $comments($class)
            }
            # if environment variable CSHARP2COM is defined,
            # add attribute to generate default interface for COM
            if { $wtype == {csharp} && "$type" == "class" && [info exists env(CSHARP2COM)] } {
                set attribute "\[ClassInterface(ClassInterfaceType.AutoDual)\]"
            }
        } elseif { $in_class && [regexp {([ \t]*)public[ A-Za-z0-9_]* ([A-Za-z0-9_]+)\(} $line string space method] } {
            # count overloaded methods
            if {! [info exists count($method)] } {
                set count($method) 0
            }
            incr count($method)
#            puts "found method: $method:$count($method)"
            # comment to the method
            if [info exists comments(${class}::${method}::$count($method))] {
                set comment $comments(${class}::${method}::$count($method))
            }
            if [info exists aDeprecations(${class}::${method}::$count($method))] {
                if { $wtype == {csharp} } {
                    set aDesc $aDeprecations(${class}::${method}::$count($method))
                    set attribute "  \[global::System.ObsoleteAttribute(\"${aDesc}\")\]"
                }
            }
        }

        # format comment by IntelliSense XML markup
        if { [llength $comment] >0 } {
            if { $wtype == {csharp} } {
                puts $fdout "$space/// <summary>"
                foreach ll $comment {
                    puts $fdout "$space/// <para>$ll</para>"
                }
                puts $fdout "$space/// </summary>"
            } elseif { $wtype == {java} } {
                puts $fdout "$space/**"
                foreach ll $comment {
                    puts $fdout "$space * $ll"
                }
                puts $fdout "$space */"
            }
        }

        # add attribute if required
        if { "$attribute" != "" } {
            puts $fdout "$attribute"
        }

        puts $fdout $line
    }

    if { $wtype == {csharp} } {
        # close namespace
        puts $fdout "\}"
        # close OCC namespace
        puts $fdout "\}"
    }
  
    close $fdout
    close $fdin

    file rename -force $wfile.new $wfile
  }
}

# restore working directory
cd "$aWorkDirBack"
